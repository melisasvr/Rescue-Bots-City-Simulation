<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rescue Bots City Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
            max-width: 1400px;
            width: 100%;
        }
        
        h1 {
            color: #1e3c72;
            margin-bottom: 20px;
            text-align: center;
            font-size: 2.5em;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }
        
        .btn-start {
            background: #4CAF50;
            color: white;
        }
        
        .btn-start:hover {
            background: #45a049;
            transform: translateY(-2px);
        }
        
        .btn-pause {
            background: #ff9800;
            color: white;
        }
        
        .btn-pause:hover {
            background: #e68900;
            transform: translateY(-2px);
        }
        
        .btn-reset {
            background: #f44336;
            color: white;
        }
        
        .btn-reset:hover {
            background: #da190b;
            transform: translateY(-2px);
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-card.success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }
        
        .stat-card.warning {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.85em;
            opacity: 0.9;
        }
        
        .canvas-container {
            border: 3px solid #1e3c72;
            border-radius: 10px;
            overflow: hidden;
            background: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }
        
        .legend-color {
            width: 18px;
            height: 18px;
            border: 2px solid #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üö® Rescue Bots City Simulation üö®</h1>
        
        <div class="controls">
            <button class="btn-start" onclick="startSimulation()">‚ñ∂ Start</button>
            <button class="btn-pause" onclick="pauseSimulation()">‚è∏ Pause</button>
            <button class="btn-reset" onclick="resetSimulation()">üîÑ Reset</button>
        </div>
        
        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="time-stat">0.0s</div>
                <div class="stat-label">Time Elapsed</div>
            </div>
            <div class="stat-card warning">
                <div class="stat-value" id="fires-stat">100</div>
                <div class="stat-label">Active Fires</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="fighting-stat">0</div>
                <div class="stat-label">Robots Fighting</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="refilling-stat">0</div>
                <div class="stat-label">Robots Refilling</div>
            </div>
            <div class="stat-card success">
                <div class="stat-value" id="extinguished-stat">0</div>
                <div class="stat-label">Fires Extinguished</div>
            </div>
            <div class="stat-card warning">
                <div class="stat-value" id="destroyed-stat">0</div>
                <div class="stat-label">Buildings Destroyed</div>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="cityCanvas" width="800" height="800"></canvas>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #555; border-radius: 2px;"></div>
                <span>Building</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff4444; border-radius: 2px;"></div>
                <span>Fire</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #333; border-radius: 2px;"></div>
                <span>Destroyed</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4CAF50;"></div>
                <span>Scout Robot</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #2196F3;"></div>
                <span>Standard Robot</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #9C27B0;"></div>
                <span>Heavy Robot</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #00BCD4;"></div>
                <span>Water Station</span>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('cityCanvas');
        const ctx = canvas.getContext('2d');
        
        // Simulation parameters
        const CITY_SIZE = 200;
        const NUM_ROBOTS = 50;
        const NUM_BUILDINGS = 1000;
        const NUM_FIRES = 100;
        const NUM_STATIONS = 5;
        
        let buildings = [];
        let robots = [];
        let fires = [];
        let waterStations = [];
        let simulationTime = 0;
        let isRunning = false;
        let animationId = null;
        let totalExtinguished = 0;
        let totalDestroyed = 0;
        
        // Scale factor for rendering
        const scale = canvas.width / CITY_SIZE;
        
        const RobotType = {
            SCOUT: 'scout',
            STANDARD: 'standard',
            HEAVY: 'heavy'
        };
        
        class Building {
            constructor(id, x, y) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.onFire = false;
                this.fireIntensity = 0;
                this.destroyed = false;
                this.fireStartTime = 0;
            }
            
            draw() {
                if (this.destroyed) {
                    // Destroyed building - dark/burned
                    const size = 4;
                    ctx.fillStyle = '#222';
                    ctx.fillRect(this.x * scale - size/2, this.y * scale - size/2, size, size);
                    return;
                }
                
                const size = 5;
                
                if (this.onFire) {
                    // Fire glow behind burning building
                    if (this.fireIntensity > 30) {
                        const glowSize = 12;
                        const gradient = ctx.createRadialGradient(
                            this.x * scale, this.y * scale, 0,
                            this.x * scale, this.y * scale, glowSize
                        );
                        gradient.addColorStop(0, 'rgba(255, 100, 0, 0.6)');
                        gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(this.x * scale, this.y * scale, glowSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Burning building - red to orange based on intensity
                    ctx.fillStyle = `rgb(255, ${Math.max(0, 255 - this.fireIntensity * 2)}, 0)`;
                    ctx.fillRect(this.x * scale - size/2, this.y * scale - size/2, size, size);
                    
                    // Add flame effect on top
                    ctx.fillStyle = 'rgba(255, 50, 0, 0.7)';
                    ctx.fillRect(this.x * scale - 2, this.y * scale - size/2 - 3, 4, 3);
                } else {
                    // Safe building - dark gray square
                    ctx.fillStyle = '#555';
                    ctx.fillRect(this.x * scale - size/2, this.y * scale - size/2, size, size);
                    
                    // Add border
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(this.x * scale - size/2, this.y * scale - size/2, size, size);
                }
            }
        }
        
        class WaterStation {
            constructor(id, x, y) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.refillRate = 50;
            }
            
            draw() {
                // Draw water station as cyan star/cross
                const size = 8;
                ctx.fillStyle = '#00BCD4';
                ctx.strokeStyle = '#006064';
                ctx.lineWidth = 2;
                
                // Draw cross shape
                ctx.beginPath();
                ctx.moveTo(this.x * scale, this.y * scale - size);
                ctx.lineTo(this.x * scale, this.y * scale + size);
                ctx.moveTo(this.x * scale - size, this.y * scale);
                ctx.lineTo(this.x * scale + size, this.y * scale);
                ctx.stroke();
                
                // Draw circle in center
                ctx.beginPath();
                ctx.arc(this.x * scale, this.y * scale, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
        }
        
        class Robot {
            constructor(id, x, y, type) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.type = type;
                this.targetBuilding = null;
                this.targetStation = null;
                
                // Type-specific stats
                if (type === RobotType.SCOUT) {
                    this.speed = 14 + Math.random() * 4;
                    this.waterCapacity = 50;
                    this.maxWater = 50;
                    this.extinguishRate = 3;
                } else if (type === RobotType.STANDARD) {
                    this.speed = 8 + Math.random() * 4;
                    this.waterCapacity = 120;
                    this.maxWater = 120;
                    this.extinguishRate = 6;
                } else {
                    this.speed = 5 + Math.random() * 3;
                    this.waterCapacity = 250;
                    this.maxWater = 250;
                    this.extinguishRate = 10;
                }
            }
            
            distance(x1, y1, x2, y2) {
                return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            }
            
            update(dt) {
                // Handle water station targeting
                if (this.targetStation !== null) {
                    const station = waterStations[this.targetStation];
                    const dist = this.distance(this.x, this.y, station.x, station.y);
                    
                    if (dist < 2) {
                        const refill = Math.min(station.refillRate * dt, this.maxWater - this.waterCapacity);
                        this.waterCapacity += refill;
                        
                        if (this.waterCapacity >= this.maxWater * 0.95) {
                            this.targetStation = null;
                        }
                    } else {
                        const dx = station.x - this.x;
                        const dy = station.y - this.y;
                        const moveDist = Math.min(this.speed * dt, dist);
                        this.x += (dx / dist) * moveDist;
                        this.y += (dy / dist) * moveDist;
                    }
                    return;
                }
                
                // Handle fire targeting
                if (this.targetBuilding === null) return;
                
                const building = buildings[this.targetBuilding];
                
                if (building.destroyed || !building.onFire) {
                    this.targetBuilding = null;
                    return;
                }
                
                const dist = this.distance(this.x, this.y, building.x, building.y);
                
                if (dist < 1) {
                    // Extinguish fire
                    if (building.onFire && this.waterCapacity > 0) {
                        const extinguish = Math.min(this.extinguishRate * dt, building.fireIntensity, this.waterCapacity);
                        building.fireIntensity -= extinguish;
                        this.waterCapacity -= extinguish;
                        
                        if (building.fireIntensity <= 0) {
                            building.onFire = false;
                            building.fireIntensity = 0;
                            fires = fires.filter(f => f.buildingId !== this.targetBuilding);
                            totalExtinguished++;
                            this.targetBuilding = null;
                        }
                    } else {
                        this.targetBuilding = null;
                    }
                } else {
                    // Move towards target
                    const dx = building.x - this.x;
                    const dy = building.y - this.y;
                    const moveDist = Math.min(this.speed * dt, dist);
                    this.x += (dx / dist) * moveDist;
                    this.y += (dy / dist) * moveDist;
                }
            }
            
            draw() {
                // Color based on type
                let color;
                if (this.type === RobotType.SCOUT) {
                    color = '#4CAF50'; // Green
                } else if (this.type === RobotType.STANDARD) {
                    color = '#2196F3'; // Blue
                } else {
                    color = '#9C27B0'; // Purple
                }
                
                // Draw robot circle
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(this.x * scale, this.y * scale, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // White outline
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x * scale, this.y * scale, 5, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner dot
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.x * scale, this.y * scale, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw line to target
                if (this.targetBuilding !== null) {
                    const building = buildings[this.targetBuilding];
                    ctx.strokeStyle = color.replace(')', ', 0.3)').replace('rgb', 'rgba');
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(this.x * scale, this.y * scale);
                    ctx.lineTo(building.x * scale, building.y * scale);
                    ctx.stroke();
                } else if (this.targetStation !== null) {
                    const station = waterStations[this.targetStation];
                    ctx.strokeStyle = 'rgba(0, 188, 212, 0.4)';
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(this.x * scale, this.y * scale);
                    ctx.lineTo(station.x * scale, station.y * scale);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }
        
        class Fire {
            constructor(buildingId, intensity) {
                this.buildingId = buildingId;
                this.intensity = intensity;
                this.spreadRate = 0.5 + Math.random() * 1.5;
            }
            
            update(dt) {
                const building = buildings[this.buildingId];
                if (building.onFire && !building.destroyed) {
                    building.fireIntensity += this.spreadRate * dt * 0.7;
                    building.fireIntensity = Math.min(building.fireIntensity, 200);
                    this.intensity = building.fireIntensity;
                    
                    // Building destruction
                    if (building.fireIntensity > 180) {
                        const timeOnFire = simulationTime - building.fireStartTime;
                        if (timeOnFire > 45) {
                            building.destroyed = true;
                            building.onFire = false;
                            totalDestroyed++;
                            fires = fires.filter(f => f.buildingId !== this.buildingId);
                        }
                    }
                }
            }
        }
        
        function initialize() {
            buildings = [];
            robots = [];
            fires = [];
            waterStations = [];
            simulationTime = 0;
            totalExtinguished = 0;
            totalDestroyed = 0;
            
            // Create buildings
            for (let i = 0; i < NUM_BUILDINGS; i++) {
                buildings.push(new Building(
                    i,
                    Math.random() * CITY_SIZE,
                    Math.random() * CITY_SIZE
                ));
            }
            
            // Create water stations (grid pattern)
            const gridSize = Math.floor(Math.sqrt(NUM_STATIONS));
            for (let i = 0; i < NUM_STATIONS; i++) {
                const row = Math.floor(i / gridSize);
                const col = i % gridSize;
                const x = (col + 0.5) * (CITY_SIZE / gridSize) + (Math.random() - 0.5) * 20;
                const y = (row + 0.5) * (CITY_SIZE / gridSize) + (Math.random() - 0.5) * 20;
                waterStations.push(new WaterStation(i, x, y));
            }
            
            // Create robots with different types
            for (let i = 0; i < NUM_ROBOTS; i++) {
                const rand = Math.random();
                let type;
                if (rand < 0.2) type = RobotType.SCOUT;
                else if (rand < 0.7) type = RobotType.STANDARD;
                else type = RobotType.HEAVY;
                
                robots.push(new Robot(
                    i,
                    Math.random() * CITY_SIZE,
                    Math.random() * CITY_SIZE,
                    type
                ));
            }
            
            // Start fires
            const fireBuildings = [];
            while (fireBuildings.length < NUM_FIRES) {
                const id = Math.floor(Math.random() * NUM_BUILDINGS);
                if (!fireBuildings.includes(id)) {
                    fireBuildings.push(id);
                    const intensity = 50 + Math.random() * 50;
                    buildings[id].onFire = true;
                    buildings[id].fireIntensity = intensity;
                    buildings[id].fireStartTime = simulationTime;
                    fires.push(new Fire(id, intensity));
                }
            }
        }
        
        function assignTargets() {
            const availableRobots = robots.filter(r => r.targetBuilding === null && r.targetStation === null);
            const validFires = fires.filter(f => !buildings[f.buildingId].destroyed && buildings[f.buildingId].onFire);
            
            for (const robot of availableRobots) {
                // Priority: fight fires if they exist and robot has water
                if (validFires.length > 0 && robot.waterCapacity > 0) {
                    let nearestFire = null;
                    let minDist = Infinity;
                    
                    for (const fire of validFires) {
                        const building = buildings[fire.buildingId];
                        const dist = robot.distance(robot.x, robot.y, building.x, building.y);
                        if (dist < minDist) {
                            minDist = dist;
                            nearestFire = fire;
                        }
                    }
                    
                    if (nearestFire) {
                        robot.targetBuilding = nearestFire.buildingId;
                        validFires.splice(validFires.indexOf(nearestFire), 1);
                    }
                } else if (robot.waterCapacity < robot.maxWater * 0.5) {
                    // Go refill if below 50%
                    let nearestStation = null;
                    let minDist = Infinity;
                    
                    for (const station of waterStations) {
                        const dist = robot.distance(robot.x, robot.y, station.x, station.y);
                        if (dist < minDist) {
                            minDist = dist;
                            nearestStation = station;
                        }
                    }
                    
                    if (nearestStation) {
                        robot.targetStation = nearestStation.id;
                    }
                }
            }
        }
        
        function update(dt) {
            assignTargets();
            
            for (const robot of robots) {
                robot.update(dt);
            }
            
            for (const fire of fires) {
                fire.update(dt);
            }
            
            simulationTime += dt;
        }
        
        function draw() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw water stations first (behind everything)
            for (const station of waterStations) {
                station.draw();
            }
            
            for (const building of buildings) {
                building.draw();
            }
            
            for (const robot of robots) {
                robot.draw();
            }
        }
        
        function updateStats() {
            const activeFires = fires.filter(f => f.intensity > 0 && !buildings[f.buildingId].destroyed).length;
            const robotsFighting = robots.filter(r => r.targetBuilding !== null).length;
            const robotsRefilling = robots.filter(r => r.targetStation !== null).length;
            
            document.getElementById('time-stat').textContent = simulationTime.toFixed(1) + 's';
            document.getElementById('fires-stat').textContent = activeFires;
            document.getElementById('fighting-stat').textContent = robotsFighting;
            document.getElementById('refilling-stat').textContent = robotsRefilling;
            document.getElementById('extinguished-stat').textContent = totalExtinguished;
            document.getElementById('destroyed-stat').textContent = totalDestroyed;
            
            if (activeFires === 0 && isRunning && fires.length === 0) {
                isRunning = false;
                alert(`‚úÖ SUCCESS! All fires extinguished in ${simulationTime.toFixed(1)} seconds!\n\nBuildings Destroyed: ${totalDestroyed}\nFires Extinguished: ${totalExtinguished}`);
            }
        }
        
        function animate() {
            if (isRunning) {
                update(0.1);
                draw();
                updateStats();
                animationId = requestAnimationFrame(animate);
            }
        }
        
        function startSimulation() {
            if (!isRunning) {
                isRunning = true;
                animate();
            }
        }
        
        function pauseSimulation() {
            isRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }
        
        function resetSimulation() {
            pauseSimulation();
            initialize();
            draw();
            updateStats();
        }
        
        // Initialize on load
        initialize();
        draw();
        updateStats();
    </script>
</body>
</html>